import org.gradle.internal.os.OperatingSystem

plugins {
    id "com.jfrog.bintray" version "1.7.3"
    id "de.undercouch.download" version "3.4.3"
}

ext {
    bintrayUser = project.findProperty('bintray.user')
    bintrayApiKey = project.findProperty('bintray.apiKey')
    signingPassword = project.findProperty('signing.password')
    ossrhUsername = project.findProperty('ossrh.username')
    ossrhPassword = project.findProperty('ossrh.password')

    pgVersionParam = project.findProperty('pgVersion') ?: ("${project.version}" - '-SNAPSHOT')
    pgBinVersionParam = project.findProperty('pgBinVersion') ?: "${pgVersionParam}-1"
    archNameParam = project.findProperty('archName') ?: ''
    distNameParam = project.findProperty('distName') ?: ''
    dockerImageParam = project.findProperty('dockerImage') ?: ''
    qemuPathParam = project.findProperty('qemuPath') ?: ''

    pgMajorVersionParam = (pgVersionParam =~ /(\d+)(\.\d+)+/).with { matches() ? it[0][1].toInteger() : null }
}

allprojects {
    apply plugin: 'java'
    apply plugin: 'maven-publish'
    apply plugin: 'com.jfrog.bintray'

    group 'io.zonky.test.postgres'
    archivesBaseName = 'embedded-postgres-binaries'
    sourceCompatibility = 1.6

    repositories {
        jcenter()
        mavenCentral()
    }

    configurations {
        bundles
    }
}

task validateInputs {
    doFirst {
        println "version:       ${project.version}"
        println "pgVersion:     $pgVersionParam"
        println "pgBinVersion:  $pgBinVersionParam"

        if (!project.version || project.version == 'unspecified') {
            throw new GradleException("The 'version' property must be set")
        }
        if (distNameParam && distNameParam != 'alpine') {
            throw new GradleException("Currently only the 'alpine' distribution is supported")
        }
        if (archNameParam && !(archNameParam ==~ /^[a-z0-9]+$/)) {
            throw new GradleException("The 'archName' property must contain only alphanumeric characters")
        }
    }
}

task downloadQemuExecutables(type: Download, dependsOn: validateInputs) {
    onlyIf { !qemuPathParam && OperatingSystem.current().isLinux() && OperatingSystem.current().getArch() == 'amd64' }
    src(['arm', 'aarch64', 'ppc64le'].collect { arch ->
        "https://github.com/multiarch/qemu-user-static/releases/download/v2.12.0/qemu-$arch-static"
    })
    overwrite false
    dest file("$temporaryDir/downloads")
}

task prepareQemuExecutables(type: Copy, dependsOn: downloadQemuExecutables) {
    from downloadQemuExecutables.dest
    into file("$temporaryDir/executables")
    fileMode = 0755
}

def repackedPlatforms = [
        ['name':'darwin', 'arch':'amd64'],
        ['name':'windows', 'arch':'i386'],
        ['name':'windows', 'arch':'amd64'],
        ['name':'linux', 'arch':'i386'],
        ['name':'linux', 'arch':'amd64']
]

def debianPlatforms = [
        ['arch':'arm32v6', 'image':'resin/rpi-raspbian:stretch'],
        ['arch':'arm32v7'],
        ['arch':'arm64v8'],
        ['arch':'ppc64le']
]

def alpinePlatforms = [
        ['arch':'i386'],
        ['arch':'amd64'],
        ['arch':'arm32v6'],
        ['arch':'arm64v8'],
        ['arch':'ppc64le']
]

def alpineVariants = [
        ['name':'', 'opt':'', 'enabled': true],
        ['name':'lite', 'opt':'-l', 'enabled': pgMajorVersionParam >= 10]
]

project(':repacked-platforms') {
    if (!distNameParam && !archNameParam && !dockerImageParam) {
        task generateRepackedPostgresBundles(group: "repacking", type: Exec, dependsOn: validateInputs) {
            inputs.property('pgBinVersionParam', pgVersionParam)

            inputs.file("$rootDir/repack-postgres.sh")
            outputs.dir("$temporaryDir/bundles")

            workingDir temporaryDir
            commandLine "$rootDir/repack-postgres.sh", "$pgBinVersionParam"
        }

        repackedPlatforms.each { platform ->
            task "${platform.arch}${platform.name.capitalize()}Jar"(group: "build (${platform.arch})", type: Jar) {
                from generateRepackedPostgresBundles
                include "postgres-${platform.name}-${normalizeArchName(platform.arch)}.txz"
                appendix = "${platform.name}-${platform.arch}"
            }

            artifacts.add('bundles', tasks.getByName("${platform.arch}${platform.name.capitalize()}Jar"))
        }
    }
}

project(':debian-platforms') {
    if (!distNameParam && !archNameParam && !dockerImageParam) {
        debianPlatforms.each { platform ->
            task "generate${platform.arch.capitalize()}DebianPostgresBundle"(group: "build (${platform.arch})", type: LazyExec, dependsOn: [validateInputs, prepareQemuExecutables]) {
                def qemuBindings = { resolveQemuBindings() }
                def dockerImage = { platform.image ?: defaultDebianImage(platform.arch, qemuBindings) }

                doFirst {
                    println "dockerImage:   ${dockerImage()}"
                    println "qemuBindings:  ${qemuBindings()}"
                    println ''
                }

                inputs.property('pgVersion', pgVersionParam)
                inputs.property('archName', platform.arch)
                inputs.property('dockerImage', dockerImage)

                inputs.file("$rootDir/repack-postgres-debian.sh")
                outputs.dir("$temporaryDir/bundle")

                workingDir temporaryDir
                commandLine "$rootDir/repack-postgres-debian.sh", '-v', "$pgVersionParam", '-i', dockerImage, '-o', qemuBindings
            }

            task "${platform.arch}DebianJar"(group: "build (${platform.arch})", type: Jar) {
                from tasks.getByName("generate${platform.arch.capitalize()}DebianPostgresBundle")
                include "postgres-linux-debian.txz"
                rename "postgres-linux-debian.txz", "postgres-linux-${normalizeArchName(platform.arch)}.txz"
                appendix = "linux-${platform.arch}"
            }

            artifacts.add('bundles', tasks.getByName("${platform.arch}DebianJar"))
        }
    }
}

alpineVariants.each { variant ->
    project(":alpine${variant.name ? '-' + variant.name : ''}-platforms") {
        if (!distNameParam && !archNameParam && !dockerImageParam && variant.enabled) {
            alpinePlatforms.each { platform ->

                task "generate${platform.arch.capitalize()}Alpine${variant.name.capitalize()}PostgresBundle"(group: "build (${platform.arch})", type: LazyExec, dependsOn: [validateInputs, prepareQemuExecutables]) {
                    def qemuBindings = { resolveQemuBindings() }
                    def dockerImage = { platform.image ?: defaultAlpineImage(platform.arch, qemuBindings) }

                    doFirst {
                        println "dockerImage:   ${dockerImage()}"
                        println "qemuBindings:  ${qemuBindings()}"
                        println ''
                    }

                    inputs.property('pgVersion', pgVersionParam)
                    inputs.property('archName', platform.arch)
                    inputs.property('dockerImage', dockerImage)

                    inputs.file("$rootDir/repack-postgres-alpine.sh")
                    outputs.dir("$temporaryDir/bundle")

                    workingDir temporaryDir
                    commandLine "$rootDir/repack-postgres-alpine.sh", '-v', "$pgVersionParam", '-i', dockerImage, '-o', qemuBindings, "${variant.opt}"
                }

                task "${platform.arch}Alpine${variant.name.capitalize()}Jar"(group: "build (${platform.arch})", type: Jar) {
                    from tasks.getByName("generate${platform.arch.capitalize()}Alpine${variant.name.capitalize()}PostgresBundle")
                    include "postgres-linux-alpine_linux.txz"
                    rename "postgres-linux-alpine_linux.txz", "postgres-linux-${normalizeArchName(platform.arch)}-alpine_linux.txz"
                    appendix = "linux-${platform.arch}-alpine${variant.name ? '-' + variant.name : ''}"
                }

                artifacts.add('bundles', tasks.getByName("${platform.arch}Alpine${variant.name.capitalize()}Jar"))
            }
        }
    }
}

project(':custom-debian-platform') {
    if (!distNameParam && (archNameParam || dockerImageParam)) {
        def archName = archNameParam ?: 'amd64'

        task generateCustomDebianPostgresBundle(group: 'build (custom)', type: LazyExec, dependsOn: [validateInputs, prepareQemuExecutables]) {
            def qemuBindings = { resolveQemuBindings() }
            def dockerImage = { dockerImageParam ?: defaultDebianImage(archName, qemuBindings()) }

            doFirst {
                println "archName:      $archName"
                println "distName:      debian-like"
                println "dockerImage:   ${dockerImage()}"
                println "qemuBindings:  ${qemuBindings()}"
                println ''
            }

            inputs.property('pgVersion', pgVersionParam)
            inputs.property('archName', archName)
            inputs.property('dockerImage', dockerImage)

            inputs.file("$rootDir/repack-postgres-debian.sh")
            outputs.dir("$temporaryDir/bundle")

            workingDir temporaryDir
            commandLine "$rootDir/repack-postgres-debian.sh", '-v', "$pgVersionParam", '-i', dockerImage, '-o', qemuBindings
        }

        task customDebianJar(group: 'build (custom)', type: Jar) {
            from generateCustomDebianPostgresBundle
            include "postgres-linux-debian.txz"
            rename "postgres-linux-debian.txz", "postgres-linux-${normalizeArchName(archName)}.txz"
            appendix = "linux-${archName}"
        }

        artifacts.add('bundles', tasks.getByName('customDebianJar'))
    }
}

alpineVariants.each { variant ->
    project(":custom-alpine${variant.name ? '-' + variant.name : ''}-platform") {
        if (distNameParam == 'alpine' && variant.enabled) {
            def archName = archNameParam ?: 'amd64'

            task "generateCustomAlpine${variant.name.capitalize()}PostgresBundle"(group: 'build (custom)', type: LazyExec, dependsOn: [validateInputs, prepareQemuExecutables]) {
                def qemuBindings = { resolveQemuBindings() }
                def dockerImage = { dockerImageParam ?: defaultAlpineImage(archName, qemuBindings) }

                doFirst {
                    println "archName:      $archName"
                    println "distName:      alpine"
                    println "dockerImage:   ${dockerImage()}"
                    println "qemuBindings:  ${qemuBindings()}"
                    println ''
                }

                inputs.property('pgVersion', pgVersionParam)
                inputs.property('archName', archName)
                inputs.property('dockerImage', dockerImage)

                inputs.file("$rootDir/repack-postgres-alpine.sh")
                outputs.dir("$temporaryDir/bundle")

                workingDir temporaryDir
                commandLine "$rootDir/repack-postgres-alpine.sh", '-v', "$pgVersionParam", '-i', dockerImage, '-o', qemuBindings, "${variant.opt}"
            }

            task "customAlpine${variant.name.capitalize()}Jar"(group: 'build (custom)', type: Jar) {
                from tasks.getByName("generateCustomAlpine${variant.name.capitalize()}PostgresBundle")

                include "postgres-linux-alpine_linux.txz"
                rename "postgres-linux-alpine_linux.txz", "postgres-linux-${normalizeArchName(archName)}-alpine_linux.txz"
                appendix = "linux-${archName}-alpine${variant.name ? '-' + variant.name : ''}"
            }

            artifacts.add('bundles', tasks.getByName("customAlpine${variant.name.capitalize()}Jar"))
        }
    }
}

subprojects {
    task sourcesJar(type: Jar, dependsOn: classes) {
        from sourceSets.main.allSource
        classifier = 'sources'
    }

    task javadocJar(type: Jar, dependsOn: javadoc) {
        from javadoc.destinationDir
        classifier = 'javadoc'
    }

    publishing {
        publications {
            configurations.bundles.artifacts.all { archive ->
                def publicationName = archive.archiveTask.name - 'Jar'
                "$publicationName"(MavenPublication) {
                    artifactId "${archive.name}"
                    configurePom(pom, artifactId, 'A lightweight bundle of PostgreSQL database with reduced size')

                    artifact archive
                    artifact sourcesJar
                    artifact javadocJar
                }
            }
        }
    }
}

publishing {
    publications {
        if (!distNameParam && !archNameParam && !dockerImageParam) {
            bom(MavenPublication) {
                artifactId 'embedded-postgres-binaries-bom'
                configurePom(pom, artifactId, 'Bill of Materials')

                pom.withXml {
                    def root = asNode()
                    root.children().last() + {
                        resolveStrategy = Closure.DELEGATE_FIRST

                        dependencyManagement {
                            dependencies {
                                project.subprojects.collectMany { it.configurations.bundles.artifacts }
                                    .sort { archive ->
                                        archive.name.replaceFirst(/^embedded-postgres-binaries-([^-]+-([^-]+).*)$/, { all, suffix, arch ->
                                            ['amd64', 'i386'].indexOf(arch).with { it != -1 ? it : 9 } + suffix
                                        })
                                    }
                                    .each { archive ->
                                        dependency {
                                            groupId "${project.group}"
                                            artifactId "${archive.name}"
                                            version "${project.version}"

                                            if (!archive.name.contains('amd64') || archive.name.contains('lite')) {
                                                optional 'true'
                                            }
                                        }
                                    }
                            }
                        }
                    }
                }
            }
        }
    }
}

allprojects {
    bintray {
        user = bintrayUser
        key = bintrayApiKey
        publications = project.publishing.publications.findAll().collect { it.name }
        pkg {
            userOrg = 'zonky'
            repo = 'maven'
            name = 'embedded-postgres-binaries'
            version {
                name = project.version
                gpg {
                    sign = true
                    passphrase = signingPassword
                }
                mavenCentralSync {
                    user = ossrhUsername
                    password = ossrhPassword
                }
            }
        }
    }

    task install(group: 'publishing') {
        configurations.bundles.artifacts.all { archive ->
            def publicationName = archive.archiveTask.name - 'Jar'
            dependsOn "publish${publicationName.capitalize()}PublicationToMavenLocal"
        }
    }

    task uploadArchives(group: 'publishing') {
        dependsOn bintrayUpload
    }

    tasks.whenTaskAdded { task ->
        if (task.name == 'publishBomPublicationToMavenLocal') {
            install.dependsOn task
        }
    }
}

def configurePom(pom, artifact, desc) {
    pom.withXml {
        def root = asNode()

        root.children().last() + {
            resolveStrategy = Closure.DELEGATE_FIRST

            name artifact
            description desc
            url 'https://github.com/zonkyio/embedded-postgres-binaries'

            scm {
                connection 'scm:git:git://github.com/zonkyio/embedded-postgres-binaries.git'
                developerConnection 'scm:git:ssh://github.com:zonkyio/embedded-postgres-binaries.git'
                url 'https://github.com/zonkyio/embedded-postgres-binaries/tree/master'
            }

            licenses {
                license {
                    name 'The Apache License, Version 2.0'
                    url 'http://www.apache.org/licenses/LICENSE-2.0.txt'
                }
            }

            developers {
                developer {
                    name 'Roman Pichlik'
                    email 'roman.pichlik@zonky.cz'
                }
                developer {
                    name 'Tomas Vanek'
                    email 'tomas.vanek@zonky.cz'
                }
                developer {
                    name 'Developers Zonky'
                    email 'developers@zonky.cz'
                }
            }
        }
    }
}

def resolveQemuBindings() {
    def bindings = fileTree(dir:"${qemuPathParam ? qemuPathParam : '/usr/bin'}", includes:['qemu-*-static']).getFiles()
    if (!bindings && !qemuPathParam) {
        bindings = fileTree(dir:prepareQemuExecutables.destinationDir, includes:['qemu-*-static']).getFiles()
    }
    return bindings.collect { "-v ${it.path}:/usr/bin/${it.name}" }.join(' ')
}

static def defaultDebianImage(archName, useEmulation) {
    def system = OperatingSystem.current()

    if (archName == system.getArch()) {
        return 'ubuntu:14.04'
    } else if (system.isMacOsX() || useEmulation) {
        return "$archName/ubuntu:14.04"
    } else if (system.isLinux()) {
        def archMappings = ['arm32v6':'armel', 'arm32v7':'armhf', 'arm64v8':'arm64', 'ppc64le':'ppc64el']
        return "multiarch/ubuntu-core:${archMappings[archName] ?: archName}-trusty"
    } else {
        throw new GradleException("Cross-building is not supported on the current platform: $system")
    }
}

static def defaultAlpineImage(archName, useEmulation) {
    def system = OperatingSystem.current()

    if (archName == system.getArch()) {
        return 'alpine:3.6'
    } else if (system.isMacOsX() || useEmulation) {
        return "$archName/alpine:3.6"
    } else if (system.isLinux()) {
        def archMappings = ['arm32v5':'armel', 'arm32v6':'armhf', 'arm64v8':'arm64']
        return "multiarch/alpine:${archMappings[archName] ?: archName}-v3.6"
    } else {
        throw new GradleException("Cross-building is not supported on the current platform: $system")
    }
}

static def normalizeArchName(String input) {
    String arch = input.toLowerCase(Locale.US).replaceAll('[^a-z0-9]+', '')

    if (arch ==~ /^(x8664|amd64|ia32e|em64t|x64)$/) {
        return 'x86_64'
    }
    if (arch ==~ /^(x8632|x86|i[3-6]86|ia32|x32)$/) {
        return 'x86_32'
    }
    if (arch ==~ /^(ia64w?|itanium64)$/) {
        return 'itanium_64'
    }
    if (arch == 'ia64n') {
        return 'itanium_32'
    }
    if (arch ==~ /^(sparcv9|sparc64)$/) {
        return 'sparc_64'
    }
    if (arch ==~ /^(sparc|sparc32)$/) {
        return 'sparc_32'
    }
    if (arch ==~ /^(aarch64|armv8|arm64).*$/) {
        return 'arm_64'
    }
    if (arch ==~ /^(arm|arm32).*$/) {
        return 'arm_32'
    }
    if (arch ==~ /^(mips|mips32)$/) {
        return 'mips_32'
    }
    if (arch ==~ /^(mipsel|mips32el)$/) {
        return 'mipsel_32'
    }
    if (arch == 'mips64') {
        return 'mips_64'
    }
    if (arch == 'mips64el') {
        return 'mipsel_64'
    }
    if (arch ==~ /^(ppc|ppc32)$/) {
        return 'ppc_32'
    }
    if (arch ==~ /^(ppcle|ppc32le)$/) {
        return 'ppcle_32'
    }
    if (arch == 'ppc64') {
        return 'ppc_64'
    }
    if (arch == 'ppc64le') {
        return 'ppcle_64'
    }
    if (arch == 's390') {
        return 's390_32'
    }
    if (arch == 's390x') {
        return 's390_64'
    }

    throw new GradleException("Unsupported architecture: $arch")
}

class LazyExec extends AbstractExecTask<LazyExec> {

    LazyExec() {
        super(LazyExec.class)
    }

    @Override
    LazyExec commandLine(Object... arguments) {
        return super.commandLine(arguments.collect { argument ->
            if (argument instanceof Closure) {
                Closure closure = (Closure) argument;
                return new Object() {
                    @Override
                    String toString() {
                        return closure()
                    }
                }
            } else {
                return argument
            }
        }) as LazyExec
    }
}